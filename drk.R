# Detta program beräknar diskonteringsräntekurvor både från idag och framåt i tiden,
# för användning till exempelvis framtida balansräkningar. Kurvorna kan enkelt skrivas till 
# Excel i tabellformat eller plottas som ytor.
# Indata är marknadsnoterade swapräntor.

# Se exempel från PROMEMORIA 2013-12-01 [FI Dnr 13-11409].
# Programmerad av Christian Savemark (maj 2019)
# Ändringar: Namn (datum)
# Ändringar består i:

discountFactors <- function(t = length(part), part) {
  i <- 2
  df <- numeric(t)
  df[1] <- 1/(1+part[1])
  while (i <= t) {
    df[i] <- (1-part[i]*sum(df[1:(i-1)]))/(1+part[i])
    i <- i+1
  }
  return(df)
}

zeroCouponRates <- function(t = 1:length(df), df) {
  (1/df[t])^(1/t)-1
}

forwardRates <- function(t, df) {
  if (t == 1) {
    return(1/df[t]-1)
  } else {
    return(df[t-1]/df[t]-1)
  }
}
vforwardRates <- Vectorize(forwardRates, vectorize.args = "t")

weight <- function(t, T1 = 10, T2 = T1+10) {
  # T1 längsta Loptiden
  # T2 tidpunkten för konvergens
  ifelse(t<=T1, 0, 
         ifelse(t>T1 & t<=T2, (t-T1)/(T2-T1+1), 1))
}

weightedForwardRate <- function(fwdr, w, T, UFR = 0.042) {
  # fwdr vektor av terminsräntor
  # w viktningsfunktion
  # T längsta Loptid
  res <- numeric(T)
  for (t in seq_len(T)) {
    res[t] <- ifelse(t<=length(fwdr), (1-w(t))*fwdr[t]+w(t)*UFR, UFR)
  } 
  return(res)
}

logLinearDFRelationshipClosure <- function(t, df) {
  # log-linjära relationer mellan diskonteringsfaktorer.
  # t är en 3-dimensionell vektor (t1, t2, t3) med t1 < t2 < t3.
  # denna funktion returnerar en funktion (det är en funktional dvs.)
  d <- t[3]-t[1]
  f <- function(x) {
    exp(((d-(t[2]-t[1]))/d)*log(df[t[1]])+((d-(t[3]-t[2]))/d)*log(1/((1+x)^t[3])))
  }
  return(f)
}

addFunctions <- function(x, l) {
  # x variabel
  # l lista av funktioner
  sum(sapply(l, function(f) f(x)))
}

multiplyFunctions <- function(x, l) {
  # x variabel
  # l lista av funktioner
  prod(sapply(l, function(f) f(x)))
}

objectiveFunction <- function(x, s, t, part, df) {
  # Målfunktion som ska minimeras.
  i <- (s+1):(t-1)
  logLinearDFRelationships <- lapply(i, function (x) logLinearDFRelationshipClosure(c(s, x, t), df))
  res <- (part[t]*(sum(df[1:s])+addFunctions(x, logLinearDFRelationships)+1/((1+x)^t))-(1-1/((1+x)^t)))^2
  return(res)
}

interestRateSwap <- function(par_t, credit.adj = -0.0035, allow.negative.rates = TRUE, stress = NULL) {
  par_t.adj <- par_t + credit.adj
  if (!allow.negative.rates) par_t.adj[par_t.adj < 0] <- 0
  df <- discountFactors(part = par_t.adj)
  zcr <- zeroCouponRates(df = df)
  fwdr <- vforwardRates(1:length(par_t.adj), df)
  while (any(is.na(df))) {
    naindex <- min(which(is.na(df))) # Least index of NAs in df
    t_1 <- naindex-1 # Largest non-NA index before NA in df
    index <- which(!is.na(par_t.adj)) # Indices that are not NA in par_t
    t_3 <- index[min(which(index>naindex))] # The smallest non-NA index that is larger than naindex
    j <- naindex:(t_3-1) # NA indices in DF
    logLinearDFRelationships <- lapply(j, function (x) logLinearDFRelationshipClosure(c(t_1, x, t_3), df))
    zcr[t_3] <- optim(par = 0.01, fn = objectiveFunction, s = t_1, t = t_3, part = par_t.adj, df = df, method = "Brent", lower = -2, upper = 2)$par
    df[t_3] <- 1/(1+zcr[t_3])^(t_3)
    m <- 1
    for (k in naindex:(t_3-1)) {
      df[k] <- logLinearDFRelationships[[m]](zcr[t_3])
      m <- m+1
    }
    fwdr[naindex:t_3] <- ((df[t_1]/df[t_3])^(1/(t_3-t_1)))-1
  }
  zcr <- zeroCouponRates(1:length(par_t.adj), df)
  datafr <- data.frame("L\u00F6ptid" = 1:length(par_t), "Marknadsnoteringar" = par_t, "Marknadsnoteringar.kred.just." = par_t.adj, "Terminsr\u00E4nta swap" = fwdr, "Diskonteringsfaktor" = df, "Nollkupongr\u00E4nta" = zcr)
  return(datafr)
}

discountFactors_2 <- function(t, fwdr) {
  i <- 2
  df <- numeric(t)
  df[1] <- 1/(1+fwdr[1])
  while (i <= t) {
    df[i] <- df[i-1]/(1+fwdr[i])
    i <- i+1
  }
  return(df)
}

nextDiscountFactor <- function(df, fwdr) {
  df_next <- df/(1+fwdr)
  return(df_next)
}

zeroCouponRate <- function(t, df) {
  return((1/df)^(1/t)-1)
}

weightedInterestSwap <- function(par_t, T, credit.adj = -0.0035, allow.negative.rates = FALSE, ...) {
  # Längsta Loptid
  # par_t marknadsnoteringar för swapräntor
  wfwdr <- weightedForwardRate(interestRateSwap(par_t, credit.adj = credit.adj, allow.negative.rates = allow.negative.rates)[ , 6], w = weight, T = T, ...)
  wdf <- discountFactors_2(T, wfwdr)
  wzcr <- zeroCouponRates(df = wdf)
  datafr <- data.frame("L\u00F6ptid" = seq(wfwdr), "Terminsr\u00E4nta viktad" = wfwdr, "Diskonteringsfaktor" = wdf, "Nollkupongr\u00E4nta" = wzcr)
  return(datafr)
}

scenarioGenerator <- function(par_t, start.year, T, UFR = 0.042, ...) {
  # Denna funktion diskonterar alla framtida kassaflöden till första året,
  # även för framtida kontrakt. Bör endast användas i sällsynta fall?
  # Output är en lista innehållandes tre matriser.
  # par_t är marknadsnoteringar för ränteswapavtal.
  # start.year är år man börjar.
  # T är antal år framåt i tiden.
  # UFR = ultimate forward rate
  vector.is.empty <- function(x) return(length(x) == 0)
  M <- matrix(NA, T, T) # Terminsräntor
  N <- matrix(NA, T, T) # Diskonteringsfaktorer
  K <- matrix(NA, T, T) # Nollkupongräntor
  wfwdr <- weightedInterestSwap(par_t, T = T, ...)[ , 2]
  M[1, ] <- wfwdr
  row <- 2
  while (!(vector.is.empty(wfwdr)) & row<=T) {
    wfwdr <- wfwdr[-1]
    M[row, seq(wfwdr)] <- wfwdr
    row <- row+1
  }
  M[is.na(M)] <- UFR
  N[, 1] <- discountFactors_2(T, M[, 1])
  N[1, ] <- discountFactors_2(T, M[1, ])
  for (i in 2:T) {
    for (j in 2:T) {
      N[i, j] <- nextDiscountFactor(N[i, j-1], M[i, j])
    }
  }
  for (i in seq(T)) {
    for (j in seq(T)) {
      if (i == 1 & j == 1) {
        K[1, 1] <- M[1, 1]
      } else {
        K[i, j] <- zeroCouponRate(t = ((i-1)+(j-1)+1), df = N[i, j])
      }
    }
  }
  rownames(M) <- rownames(N) <- rownames(K) <- start.year:(start.year+T-1)
  colnames(M) <- colnames(N) <- colnames(K) <- seq(T)
  return(list("Terminsr\u00E4nta viktad" = M, "Diskonteringsfaktor" = N, "Nollkupongr\u00E4nta" = K))
}

scenarioGenerator_2 <- function(par_t, start.year, T, stress = NULL, UFR = 0.042, ...) {
  # Denna funktion diskonterar bara till varje nytt år.
  # (används t.ex. för diskontering vid framräkning av framtida balansräkningar)
  # Output är en lista innehållandes tre matriser.
  # par_t är marknadsnoteringar för ränteswapavtal.
  # start.year är år man börjar.
  # T är antal år framåt i tiden.
  # stress är en stressvektor vars längd måste vara lika med T.
  # UFR = ultimate forward rate
  if (!is.null(stress) & length(stress) != T)
    stop("Stress vector is not the same length as T")
  vector.is.empty <- function(x) return(length(x) == 0)
  M <- matrix(NA, T, T) # Terminsräntor
  N <- matrix(NA, T, T) # Diskonteringsfaktorer
  K <- matrix(NA, T, T) # Nollkupongräntor
  wfwdr <- weightedInterestSwap(par_t, T = T, ...)[ , 2]
  M[1, ] <- wfwdr
  row <- 2
  while (!(vector.is.empty(wfwdr)) & row<=T) {
    wfwdr <- wfwdr[-1]
    M[row, seq(wfwdr)] <- wfwdr
    row <- row+1
  }
  M[is.na(M)] <- UFR
  for (i in seq(T)) {
    N[i, ] <-  discountFactors_2(T, M[i, ])
  }
  K[1, ] <- M[1, ]
  K[, 1] <- M[, 1]
  for (i in 1:T) {
    for (j in 2:T) {
        K[i, j] <- ((1+M[i, j])*(1+K[i, j-1])^(j-1))^(1/j)-1
    }
  }
  if (!is.null(stress)) {
    stress.last <- stress[length(stress)]
    K[1, ] <- K[1, ]+stress
    row <- 2
    while (row<=T) {
      stress <- c(stress[-1], stress.last)
      K[row, ] <- K[row, ]+stress
      row <- row+1
    }
  }
  rownames(M) <- rownames(N) <- rownames(K) <- start.year:(start.year+T-1)
  colnames(M) <- colnames(N) <- colnames(K) <- seq(T)
  return(list("Terminsr\u00E4nta viktad" = M, "Diskonteringsfaktor" = N, "Nollkupongr\u00E4nta" = K))
}